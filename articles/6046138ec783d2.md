---
title: "Goã§ãƒ†ã‚­ã‚¹ãƒˆã‚’æš—å·åŒ–ã™ã‚‹"
emoji: "ğŸ˜¸"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: [golang]
published: true
---

# æ¦‚è¦
æš—å·åŒ–æ–¹å¼ï¼šAES  
ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼šcrypto/aes, crypto/rand

# AESã«ã¤ã„ã¦
AESã¨ã¯ã€ç„¡ç·šLANãªã©ã«ç”¨ã„ã‚‰ã‚Œã‚‹æš—å·åŒ–ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ä¸€ã¤ã€‚  
ã‚¢ãƒ¡ãƒªã‚«å›½ç«‹æ¨™æº–æŠ€è¡“ç ”ç©¶æ‰€ã¨ã‹ã§ã‚‚æ¡ç”¨ã•ã‚Œã¦ã„ã‚‹ä¿¡é ¼æ€§ã®é«˜ã„æ‰‹æ³•ã€‚
ç§˜å¯†éµãŒ16Byteã‚ã‚Šã€DESã®8Byteã«æ¯”ã¹ã¦é•·ãã€ãã‚ŒãŒä¿¡é ¼æ€§ã®é«˜ã•ã®è¦å› ã‚‰ã—ã„ã€‚
æš—å·åŒ–ã§ãã‚‹Byteé•·ï¼ˆ=ãƒ–ãƒ­ãƒƒã‚¯ï¼‰ã¯16Byteã§ã€ãã‚Œä»¥å¤–ã®é•·ã•ã®ç‰©ã¯æ‰±ãˆãªã„ã€‚  

### 16Byteä»¥å¤–ã®ãƒ‡ãƒ¼ã‚¿ã‚’æš—å·åŒ–ã™ã‚‹æ–¹æ³•
ä»Šæœ«å°¾ã«æ–‡å­—ã‚’åŠ ãˆã‚‹ã“ã¨ã§16ã®å€æ•°é•·ã«ã—ã€16Byteãšã¤æš—å·åŒ–ã™ã‚‹
ã“ã®16ã®å€æ•°é•·ã«å¤‰æ›´ã™ã‚‹å‡¦ç†ã‚’ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã¨ã„ã„ã€16Byteãšã¤ç¹°ã‚Šè¿”ã—æš—å·åŒ–ã™ã‚‹æ“ä½œã‚’ãƒ¢ãƒ¼ãƒ‰ã¨å‘¼ã¶ã€‚
ä»Šå›ã¯CBCãƒ¢ãƒ¼ãƒ‰ã¨ã€PKCS#7ã¨ã„ã†ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°æ‰‹æ³•ã‚’æ¡ç”¨ã—ãŸ

### åŒã˜æ–‡å­—åˆ—ã¯æ¯å›åŒã˜æ–‡å­—ã«æš—å·åŒ–ã•ã‚Œã‚‹å•é¡Œ
AESæ–¹å¼ç­‰ã§æš—å·åŒ–ã™ã‚‹å ´åˆã€åŒã˜ç§˜å¯†éµã§åŒã˜æ–‡å­—åˆ—ã‚’æš—å·åŒ–ã™ã‚‹ã¨ã€æ¯å›åŒã˜æ–‡å­—ã«æš—å·åŒ–ã•ã‚Œã‚‹ã¨ã„ã†ã“ã¨ãŒèµ·ãã€
è§£èª­ã•ã‚Œã¦ã—ã¾ã†å¯èƒ½æ€§ãŒé«˜ã¾ã‚‹ã€‚
ã“ã‚Œã‚’é˜²ããŸã‚ã«ã€æš—å·åŒ–ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã®å…ˆé ­ã«ãƒ©ãƒ³ãƒ€ãƒ ãªãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ ã™ã‚‹ãªã©ã—ã¦ã€åŒã˜ãƒ‡ãƒ¼ã‚¿ã§ã‚‚åŒã˜æš—å·æ–‡ã«æš—å·åŒ–ã•ã‚Œã‚‹ã“ã¨ã‚’é˜²ãã“ã¨ãŒã§ãã‚‹ã€‚
ã“ã®ãƒ©ãƒ³ãƒ€ãƒ ãªãƒ‡ãƒ¼ã‚¿ã®ã“ã¨ã‚’åˆæœŸåŒ–ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆIVï¼‰ã¨ã„ã†ã€‚
CBCãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€ä»•æ§˜ä¸Šãƒ‡ãƒ¼ã‚¿ã®å…ˆé ­ã«IVã‚’æŒ¿å…¥ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
DBã«æš—å·æ–‡ã‚’ä¿æŒã™ã‚‹å ´åˆã€å¾©å·åŒ–ã«ã¯IVã‚‚å¿…è¦ã§ã‚ã‚‹ãŸã‚ã€æš—å·æ–‡ã¨ä¸€ç·’ã«DBã«ä¿æŒã™ã‚‹ã“ã¨ãŒå¿…è¦ãŒã‚ã‚‹ã€‚

# ã‚³ãƒ¼ãƒ‰

### æš—å·åŒ–
``` go
import (
	"crypto/aes"
	"crypto/rand"
    "bytes"
    "crypto/cipher"
)

func GenerateIV() ([]byte, error) {
	iv := make([]byte, aes.BlockSize)
	if _, err := rand.Read(iv); err != nil {
		return nil, err
	}
	return iv, nil
}

func Pkcs7Pad(data []byte) []byte {
	length := aes.BlockSize - (len(data) % aes.BlockSize)
	trailing := bytes.Repeat([]byte{byte(length)}, length)
	return append(data, trailing...)
}

func Encrypt(dataString , keyString string) (iv []byte, encrypted []byte, err error) {
    key = hex.DecodeString(key)
    data = hex.DecodeString(dataString)

	iv, err = GenerateIV()
	if err != nil {
		return nil, nil, err
	}
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, nil, err
	}
	padded := Pkcs7Pad(data)
	encrypted = make([]byte, len(padded))
	cbcEncrypter := cipher.NewCBCEncrypter(block, iv)
	cbcEncrypter.CryptBlocks(encrypted, padded)
	return iv, encrypted, nil
}
```


### å¾©å·åŒ–
``` go
func Pkcs7Unpad(data []byte) []byte {
	dataLength := len(data)
	padLength := int(data[dataLength-1])
	return data[:dataLength-padLength]
}

func Decrypt(data , keyString, iv string) ([]byte, error) {
    key = hex.DecodeString(key)
    iv = hex.DecodeString(ivString)
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}
	decrypted := make([]byte, len(data))
	cbcDecrypter := cipher.NewCBCDecrypter(block, iv)
	cbcDecrypter.CryptBlocks(decrypted, data)
	return Pkcs7Unpad(decrypted), nil
}
```

# å‚è€ƒè¨˜äº‹

https://qiita.com/p5750/items/d06a3f95c7a453efbb74

https://pkg.go.dev/crypto/aes

https://pkg.go.dev/crypto/cipher
