---
title: "Domain Modeling Made Functionalを読んでみる"
emoji: "📗"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ['DomainModelingMadeFunctional']
published: true
---

## この記事について
私が気になった部分やわからなかった部分をメモしていきます。
Domain Modeling Made Functionalの本を要約解説するものではありません。

# 1章 Introducing Domain-Doriven Design
この章は、DDDの基本的な思想について説明されている。
例えば、ドメインエキスパートだけでなく開発チーム全体がドメインについて理解する必要があること、その理解をチームで共有することなど。
高次元のドメインの概念だと、紙だろうがシステムだろうが変わらないはずであるというのは良い言葉。
結構ドメインイベント周りが厚く説明されていて、これからキーになりそう感ある。
ドメインイベントとそれを実行するコマンドのつながりを理解する必要があるっぽい。
1.コマンドが実行される
2.コマンドが成功する
3.ドメインイベントが起きる。
4.ドメインイベントが次に起こすイベントのコマンドを叩く。
この流れで、ひとつながりのプロセスが実行されていく。
大きなドメインは理解できる程度に小さく切り分ける。
"ドメインエキスパートがやっていること"がドメインであるっていうのは、なかなか思い切っているけど良い定義だと思った。
ドメインエキスパートが言うこと・考えていることの一つひとつがドメインそのものと捉えても良さそう。
業務を理解できたら、境界づけられたコンテキストを正しく切ることがまずは大事。
境界を見つけるコツは、
- ドメインエキスパートに聞くこと
- チームや部署の区分けに注目すること
- 大きなコンテキストを作らないこと
- 独立したコンテキストになっているかに着目すること

どんな設計も静的なものではない。
コアなドメインを特定する。基本的には、顧客が最も価値を感じる領域がコアになる。
ユビキタス言語を作りましょう。

トリガー（コマンド）とイベントの違いがちょっと分かりにくかった。
一章はここまで。

# 2章
インタビューは、先入観を持たずドメインの知識を得ることに専念する。
ワークフローの出力は常に次のイベントをトリガーするものである。
→関数型っぽい話しているけど、いまいちわからない。
　注文確認書が出力ではないと言ったこととの違いは何か？アクションではないといけない理由は何？
 トリガーと前章のコマンドの違いは何？
データベースドリブンではなく、モデルドリブンに設計しよう。
　→結構難しいですね。。どうしてもモデルを解釈しながらDBを考えてしまうところがある。みなさんどうですか？
データベースから設計してしまうとモデルをデータベースの都合で捻じ曲げてしまう⇨なるほど。やってしまいそう。
クラスドリブンもだめ。辛い。
技術的なアイデアは後回しにして、まずはドメインに耳を傾けるのだ！
テキストベースの擬似プログラミングでドメインを文書化していく。
→あくまでクラスやDBを作るのではなく、ドメインを少し構造化して捉えることに集中する。
カタログのコピーを持っている件も、ドメインにはならないかもしれないけれど、ニーズ（＝各部署独立して働きたい）を理解する上では必要
→こういう無駄そうなことしている時ってサラッと話を流してしまうことあるけど、これらからニーズを拾っていくことも重要なのね。
ユビキタス言語は結構細かく厳密に作成していく。甘くしてしまうと、設計が形を為さなくなる。
ドメインエキスパートのメンタルモデルにも着目しながら、ドメインを設計する。

# 3章
インタビューやイベントストーミングによって知識を補ってきたが、それをどう設計に繋げるのか。
プロトタイプを作って早めにフィードバックをもらう
C4の話は抽象的すぎてちょっとわからない。
初めから境界を正しく設計するのは難しい（そもそも境界は変化するもの）
モノリスに作ってから、必要に応じてリファクタリングしていくのが良い方法。
コンテキスト間のメッセージングはいろんな方法がある。キュー（Pub/Sub?）は良い方法の一つ。非同期でマイクロサービスでもモノリスでもどちらでも使える。
関数を呼ぶのって依存関係なし（独立している）といえるの？
コンテキスト間で共有可能なDTOを使うことで独立にすることが可能→なるほどね。。DTOをコンテキスト外に定義することにちょっと抵抗感ある。
共通のDTOでメッセージングするのではなく上流DTO⇨JSON/XML⇨下流DTOと言う感じにする。これは良さそう。だけど、一旦JSON挟むの面倒だな。。
[Anything inside the bounded context will be trusted and valid, while anything outside the bounded context will be untrusted and might be invalid.]外部に依存していないことが言いたいのかな？
インプットゲート部分でバリデーションかけるのは良さそう。
アウトプットはセキュリティ意識！
「共有カーネル」・・・お互いが共通のものに依存している。その共通のものの変更には協議がいる
「コンシューマー・サプライヤー」・・・下流が上流に必要なものの提供を求める形式（例：オーダーと通知）
「順応者」・・・下流は上流の変更をそのまま受け入れる形式(例：プロダクトカタログ)
この三つの形のリレーションがある。なるほど。
腐敗防止層パターン・・・レガシーなものとの間に層を設けて独立させる⇦これもインプットゲートになるのか
「The relationship between the order-taking and shipping contexts will be a “Shared Kernel,” meaning that they will jointly own the communications contract.」ここちょっと分かりにくい。。
逆コンウェイの法則！


## 4章
Understanding Functions
関数のイメージ：何かが入り、何らかの形で変換され出てくる。

Types and Functions
関数型プログラミングでは、変数やオブジェクトではなく値と言う単語を使う。
オブジェクト指向では、オブジェクトが値と動作をカプセル化したもので、内部に状態を保つことなる。
これに対して、関数型ではほぼ全てが値であり、関数も「ある型から別の型に値を変更する」型の値であると言える。
図として関数を書いてみる
値、オブジェクト、変数の違い
値：型のメンバーのこと。不変であり、関数も入力(型)→出力(型)に変更する形のメンバーの一つと考えられる
オブジェクト：状態をもつ（状態は変化するもの）
変数：変数は”変化”するもの

Composition of Types
ANDタイプとORタイプの二つがある
ANDタイプ：レコードと呼ぶ。複数の型の複合。F#の複合型のは、クラスとかGoだと構造体にあたる物。
ORタイプ：チョイスと呼ぶ。
101:チョイスは、enumみたい。チョイスにはタグをつける必要がある。
101:これはチョイスに同じ型を複数登録することがしばしばあるため、それらを見分けるときに使う。→結構イメージついてない
関係ないけど、リンゴの型に富士が出てきたのは結構熱い。
104:代数型プログラミングというのはなかなか面白いのかも？「代数的な型システムとは、単純に、すべての複合型が、より小さな型をANDまたはORすることによって構成されるシステムのことである。」
algebraic type systemの話は面白そうなので、少し調べる

Working with F# Types
105:パターンマッチを使って、関数の出力を変化させる方法(match with)の紹介
105:[let​ printQuantity aOrderQty = ...]の書き方をするとなると、新しい型を追加するたびにこんなふうに全部のメソッドを変更しないといけないのだろうか。ちょっと辛いな。新しい型を追加した時の影響範囲の調べ方どうやってやるんだろうか。

Building a Domain Model by Composing Types
1.単純型(値オブジェクト)を作る。
2.次にレコード型（構造体）、チョイス型を作る。
支払い方法の定義だとまず値オブジェクトとして、それぞれの支払い方法を定義した後、それらをチョイス型”支払い方法”として定義している。
支払いのレコードは、金額、通貨単位、支払い方法のレコードとして定義
↑のメソッドは支払い方を定義したもの。現金かカードかなど。
そしてこれらの情報をまとめて、「支払い」という一つの単位ができる。
108:ここまでをまとめると、↑まずは型を作り、その型の遷移をメソッドとして定義していく。というのが関数型の流れっぽい。

Modeling Optional Values, Errors, and Collections
レコードとチョイスはnullを許容していない。
Option<T>をつけるとNullが許容された型を定義できる
オブションラベルもある

エラーの書き方
Result型を定義Result<​'​Success,​'​Failure>
これは、チョイス型で、関数で​Success,​Failureのどちらかを返すように作れる
例：type​ PayInvoice = ​  UnpaidInvoice -> Payment -> Result<PaidInvoice,PaymentError>
PaymentErrorはチョイス型で宣言しておくと、エラーの種別も作成可能

戻り値のない関数
何も返却しないメソッドは書けないが、そういうことをしたい時はunitを使う。
例えば顧客を保存するメソッドの戻り値をunitにするなど。
引数が何もないときも引数にunitを置く。

リスト、コレクション
list, array, ResizeArray, seqが存在する
listはイミュータブルで不変長。
ドメインモデリングではlistと使う
optionと同じように宣言できる
type​ Order = { ​  OrderId : OrderId ​  Lines : OrderLine ​list​ ​// a collection​ ​  }

Organizing Types in Files and Projects
コンパイル順の早いファイルは、遅いファイルを参照できない。
type→domain→common→Order Takeing→Shippingの準にコンパイルする

同ファイル内でも同様で、型の宣言は上から順に宣言されている必要があり、下流の型を使って上流の型をコンパイルできない。
例外的に可能にする方法(rec, and)も用意されているが、リリース前までには正しい依存関係に並べ替える方が良い。



F# の 文法まとめ
- 関数関連
let で関数定義を宣言
returnはなく、最後に表現されたものが戻り値になる。
関数の範囲はインデントで区切る(Pythonみたい)
関数で型を宣言する必要はなく、推論してくれる。
汎用型は'aと表現する

同じかどうか判定する比較演算子は=一つ

レコード型の値の宣言
let​ aPerson = {First=​"Alex"​; Last=​"Adams"​}
レコード型の値の分解
let​ {First=first; Last=last} = aPerson


# 5-7章は省略
7章は自分でもまとめてみたいかも

# 8章
関数型での書き方
Currying, Bakeing in は面白いね。
複数パラメーターの関数を複数の1パラメーター関数の複合体と考えることができる
つまり、3パラメーターの関数を1+1+1, 1+2, 2+1のどれと捉えてもいいってことなのかな？
composionのpipingはOOPだと関数の戻り値をそのまま関数に突っ込んでいる時の感じかな。
ただとても見やすい。
workflowのpipingがapplicationになるところはちょっとよく分からない。in parallelはcomposeなのか？

# 9章
バリデーションとバリデーション済の型を返すメソッドを分けて実装するのは面白い
Implementing the Rest of the Steps
> 必ず起きるイベントも起きないかもしれないイベントもリストで返却する。起きないかもしれないイベントが起きない時も空のリストを返却するようにする
それぞれ別の型を共通のイベント型に変換するのをリフティングと呼ぶ

DIの方法としてモナドもあるけどpartial applicationを使う
参考:https://qiita.com/tadsan/items/cec2851f70838e42be46
関数型プログラミングではいわゆるDIはせず、パラメーターとして明示的に渡すようにする
依存を引数で渡していくのは、依存を解決するトップレベルのメソッドまで続ける必要がある。→これはちょっとめんどくさい
だけど、これによってテストしやすくなる

たくさんの依存があったらどうするか？→1.メソッドを分解する、2.依存をグループ化する
引数が複数必要な関数も、ワークフローを始める前にいくつか引数をセットできるのであれば、先にセットした関数を用意してそれを使うようにする

# 10章
エラーハンドリングについて
エラーも大事な存在である
主にエラーは三種類ある。
ドメインエラー：ビジネスプロセスの中で生じるエラー（→ドメイン知識である）
パニック：アウトオブメモリー等のハンドル不能のエラーやプログラムのミス（ぬるぽとか）
基盤エラー：そのほかドメインには含まれないエラー（認証失敗とかタイムアウトとか）

どれがドメインエラーなのかはドメインエキスパートに聞こう！
ドメインエラーはドメインの一部なので型定義するのがいい。

モデル化したくないエラー（パニック、基盤エラー）はトライキャッチすればOK！
だけど基盤エラーの取り扱いはドメインエキスパートとよく相談して決めるほうがいい

ドメインエラーにはチョイス型を使おう

ライブラリ等を使用している場合は、例外を返さないといけないこともある.
ドメインに関係する例外は例外はドメインエラーとしてキャッチする.
それ以外は、普通に例外を起こして、それで止まるってことでいいのかな？

I/Oへの書き込み等続きがない処理の場合はどうするのか？
関数自体を引数に取るアダプター関数を作成して、Resultを返すようにすることで、次のパイプラインにつなげられるようにする？
⇨細かい話だけどトランザクションの管理とかどうなるんだろう？同じコンテキスト内では流石に整合性を取れるようにしておきたいが、、
あと、全く何も返さない関数って実際どの辺にあるのだろうか？I/Oへの書き込みはエラーが起きうるし、どういうケースを想定した話をしているのだろうか？
logへの出力とかそういうもの？
let!で中身を取りに行けるの面白いし便利。let!を使ってもErrorの型を一致させるためにmapErrorは必要らしい
非同期Resultを使う場合は、すべてのResultを非同期Result型に合わせる必要があるので、そのマッピングが必要になるがlet!を使えばそんなに複雑なものにはならない

# 11章
Parsisitanceの意味は固執するとかより、永続化または一般的な形に変更することを指している
BoundedContext間の密な結合は避けるために、DTOによる縛りは弱いものになってしまうが、変更は慎重に行うようにしましょう→確かに。安易にドメインモデルで送り合うことはやるべきではないし、（マイクロサービス化などを考えると）できないよね。ただし、モノリスの間はそこまで明確にBoundedContextを意識しなくてもいいのでは？
デシリアライズ化のコードで例外を返すか、パニックにするかは、APIの公開度や呼び出し元の信頼度による→公開度が高い場合はPanicより例外をしっかり決めてそれを返してあげるほうが親切で、信頼度が高い（つまりは決まった呼び出し元から呼ばれる場合）はパニックでよいということかな。
toDomainでドメイン作成前にバリデーションかけているのはなぜ？domainのコンストラクタか、型システムを使ったvalidateメソッドでかけるのがいいのでは？
P329: inputにかけるバリデーションってDomainに関係するバリデーションじゃなくて値の有無とかもう少し簡単なもの？でもその場合は、toDomainではなくてInputのバリデーションメソッドとして書いたほうがいいような？
P334:Domainの境界とか名前は変わっていくものだけど、シリアライズ型の名前はコントラクトがあるので簡単に変えるべきではない→公開されているAPIを想定した話でモノリスの場合のBoundedContext間やただのAPIサーバーの場合はDomainに合わせて名前を変えて行ったほうが良さそうだけどどうなんだろう？
P341:型の違うチョイス型もタグを使って表現できる。GraphQLのEnum型（Interface?）にちょっと似ている？
P343:すべての値をタプルKey-Value(obj)のタプルにしてしまうという方法もある。この場合Resultの型にジェネリクスを使うことができる
ここでジェネリクスを使うメリットデメリットってなんだろうか？ケースバイケースだからひとまずあまり気にしなくて良さそうなのかな。

# 12章
テーマは、永続化
これまで、この本では、実装上の諸課題（データの保存や外部サービス）を無視してきたが、この章ではそこに目をむけている。

永続化を組み込むとだいたいの場合で、完璧なドメインモデルとミスマッチするようになる
ポイントは３つ
Push persistence to the edges.→DDD、クリーンアーキテクチャ
-- 永続化は端に追いやる
Separate commands (updates) from queries (reads).→CQRSパターン
-- 更新とReadは分ける
Bounded contexts must own their own data store.→？
-- ドメインんコンテキスト毎にデータストアを持つ

最後の一つは少し難しいなあ

Push persistence to the edges.
理想的には全ての関数が純粋であることが望ましい(純粋=副作用がない↔︎永続化)
ワークフローにはできるだけ永続化のロジックが含まれないように作るのが理想。
そのため、ワークフローを大きく二つのパートに分けることが望ましい
- ビジネスロジックを含む「ドメイン中心」部分
- I/O 関連のコードを含む「エッジ」部分

例として、支払いの記録するコードを例に挙げている
支払いがすべて完了していれば、完了のフラグを立て支払い完了のイベントを発火し、支払いが一部のみ完了したのであれば、その旨を記録するだけ

一つ目の例は、一つのメソッド内でデータの読み込み、支払いが完了したかどうかの判断、DBへの書き込み/イベントの発火を全て行っている。
このコードでは純粋ではないので、テストがしにくい。

そのため、ビジネスロジックだけを取り出した純粋な関数を用意する例を提案している、

つまりは、以下のロジックを判断してくれる関数を用意している。

未払いの請求書, 支払い →　請求書の支払い結果（支払い完了/未完了） 

この関数は純粋であるため、容易にテストできる。

あとはこの関数の上流で、データの読み込み、下流でデータの保存を行うようにする
つまりは、データの読み込み(純粋でないコード)→判断ロジック（純粋なコード）→判断結果の実行(データの書き込み等、純粋でないコード）というように
純粋なコードを純粋でないコードで挟んだコードを作る。

この関数はそれ自身は何も決定せず、内側のドメイン中心関数によって行われた決定を処理するだけであることに注意してください。
そのため、永続化ロジックはそれ単体をテストする必要はない。ただテストが必要ないという意味ではなく、統合テストで一緒にテストする。
どうしても永続化ロジックだけをテストしたいなら、外部から注入する作りにしておくべきである
→これは、dependencyとかで外部から引数として渡せるようにしておくことを言っている。
外部から渡せるようにしてあれば、永続化ロジックがこの関数から切り離されているので、それ単体でテストできる。
　
サービスのテストを統合テストではなく単体テストにしたいならってこと？
I/Oとロジックのサンドイッチがあまりに多重になるようなら小さいワークフローに区切った実装に変更する←たぶん色々やろうとしすぎているってこと
関数型のこの実装方法ではリポジトリーパターンはいらなくなる。
    ←結局同じことしているように思ったけど、リポジトリーパターンとの違いってなんだろう？
        クラスにまとまっていないこと
        リポジトリーを作らず、必要なときに必要な関数をそれぞれ実装する（再利用はあまりかんがえていないのかも？）

Separate commands (updates) from queries (reads).
データの更新もイミュータブルにする
Insert, Update, Deleteはデータストアの状態が変化するが、Read(query)は変化しない
だからCQSではCとQを一緒に扱わない

 データを返す関数は副作用を持つべきではない。
 副作用（状態の更新）を持つ関数は、データを返してはいけない、つまり、unitを返す関数（戻り値がない関数）でなければならない。

CとQで同じ型を使うべきではない理由
- CとQで必要な情報が異なることが多い
　　- QではIDが必要だったり、計算結果の値が欲しかったりなど。
- CとQは独立して成長していく傾向がある
  - C1つに対して、Qの数がどんどん増えていく場合など
- パフォーマンス面から
  - Qでは複数テーブルの情報をまとめて取得したいケースも多い

この法則はDB自体にも適用できる
- 書き込みに最適化されたデータストア（インデックスなし、トランザクション型など）
- クエリに最適化されたデータストア（非正規化、重インデックスなど）
これは物理的にテーブルを用意しましょうという話ではなく、Veiwとか使いましょうという話
物理的にも分けるならどうやって同期取るか考える必要がある、これは余計な作業なのでそれに見合うメリットがあるか良く検討しましょう。
リード側がライト側よりデータが古くなる可能性が高く、これを許容できるかはドメインによる。

CQRSはイベントソーシングと一緒に語られることも多いようです。
ただここで詳しく（正しく？）語るスペースはないとのこと。
「"会計士は消しゴムを使わない "」


Bounded contexts must own their own data store.
以下の二つが大事
- 境界付きコンテキストは、独自のデータストレージと関連するスキーマを所有する必要があり、他の境界付きコンテキストと調整することなく、いつでもそれらを変更することができます。
- 他のシステムは、束縛されたコンテキストが所有するデータに直接アクセスすることはできません。その代わりに、クライアントは、束縛されたコンテキストのパブリックAPIを使用するか、データストアのある種のコピーを使用する必要があります。
これらはコンテキストがそれぞれ独立して成長できるために必要なこと
データベースをコンテキスト毎に物理的に分けて保持するケースも、一緒のデータベースだがネームスペースで分けるケースもある。これらは設計のニーズや運用チームの要件によって様々。
レポーティングで複数コンテキストからデータを集めてきたい場合も複数DBに接続するのはよくないアイデア。
レポーティング用にほかDBからデータを取得してきて、独自のDBを持つようにするべき。OLTP,OLAP参照
やり方はさまざまで、純粋な方法として他ドメインのイベントをサブスクライブするというものもある。
他にはデータをコピーしてくる方法（導入は簡単だが、スキーマの変更に弱い）などもある。

BIの領域ではちゃんとしたドメインモデルが必要なケースは少なく、それよりアドホックなクエリなどに対応できる多次元データベースが重要
この考えは、オペレーション（たぶんBIではない業務アプリケーションの方）でも同じように考えられる。→CとQを別ドメインとして扱うこと

## ドキュメントデータベースでどう実装するか
JSONやXMLの文字列をそのまま保存するだけ

## RDBでどうじっそうするか
関数型との親和性はいい。

ただ、ドメイン型をDBでは使えないし、チョイス型もそのまま扱えない。

#### チョイス型をテーブルにマッピングする

- 同じテーブルに全て入れる
- テーブルを分ける

###### 同じテーブルに全て入れる
- どのケースが使われているかを示すフラグが必要(よく〇〇Typeみたいな名前をつけるカラムとか)
- Nullableのカラムが発生する

単一のTag VARCHARフィールドではなく、それぞれのケースにビットフィールドフラグを使用したのは、その方が若干コンパクトでインデックスが作りやすいから。
→なるほど？でも管理しにくいし、ありえないケースがわかりにくいと思ってしまう。

###### テーブルを分ける
- 主テーブルと、型ごとの子テーブルに作成する
- 複雑にはなるが、DBの制約を使えるようになる

ケースに関連するデータが多く（カラムが多い？）、ケースごとの共通点が少ない場合は有効。それ以外は1テーブルの形で良い。

#### ネストしている型
外部キー制約を使う

#### F#でのデータ取得
ORMは使わず、生のSQLコマンドを使うことが多い

SQLタイププロバイダってなんだ？　調べる→FSharp.Data.SqlClient
SQLCみたいにSQLのクエリごとに型を作って、マッピングするプロバイダのこと

「別のファイルが生成されず、型がその場で作成されることが異なります」どういうこと？コンパイル時に型が作られるってなに？

データを取得したら、型変換の関数を通して、値オブジェクトに変換。
型に齟齬があれば、Result.bindOptionというヘルパー関数を通す
全部Result型で返すのは、ちょっと面倒だけど一度書いてしまえばエラーもない（のでかんばれってこと？？）

一方、データベースに不正なデータが含まれることはないと確信しており、万が一含まれた場合はパニックになっても構わないと考えている場合は、代わりに不正なデータに対して例外をスローするのでOK。→それでいいなら楽。どんなときにこれができるのだろう？

panicOnErrorのメソッドがちょっと気になる。DatabaseErrorって名前は合っているのか？

P375
「まず、「本番」接続として使用する SqlConnection を明示的に渡すようになったことに注意してください。」
これは、このライブラリだからの話では？
データを取得したら、件数が意図したものだったか(0,1,2以上か)をチェック
→大変だけど、後ろの工程でヌルポとか起きるよりいいでしょ？

ジェネリクスメソッドにして、テーブル名などをパラメーター化し、いろんなテーブルでつかえるものにすることも可能。
P377
ToDomainでドメインモデル作成時にもバリデーションしている
→IsEmailのとき、EmailAddressがあるかどうか

P378のパイプラインで繋げて、データ取得からDomainModelへのコンバートまで表現するのは面白い
「ORMを使えばいいと思うかもしれないけれど、ドメインの整合性を確保したいのであれば、そうはいきません。前述のようなORMでは、メールアドレスや注文数の検証、ネストした選択型の処理などはできません。確かに、このようなデータベースのコードを書くのは面倒ですが、このプロセスは機械的でわかりやすく、アプリケーションを書く上で最も難しい部分ではないのです！」
なるほど？でも、Fetch毎に整合性確認するのは面倒だな。あと、複数テーブルにまたがる整合性の確認とかは複雑すぎるので現実的ではない気もして、それならここでできる整合性の確認は限定的なものになりそう。注文数の検証は、保存時とデータ取得時で在庫数に変更があるかもしれないので使えるかも？

#### DBへの書き込み
ORMを使った方法
より生のSQLに近い方法

## トランザクション
複数の集約をまとめて保存したい場合は、トランザクションを使いましょう
データストアの種類によっては、一つのコネクションを使用している場合にしかトランザクションを使えないものもある。→結構一般的にそうかも？

複数サービスに対して通信を行う場合など、トランザクションを張ることが不可能な場合もある。
「一般的にビジネスでは、オーバーヘッドや調整コストが重くて時間がかかるため、異なるシステムをまたぐトランザクションは必要ない。その代わりに、ほとんどの場合、物事はうまくいくと仮定し、矛盾を検出するための調整プロセスや、エラーを修正するための補償トランザクションを使用します。」
補償トランザクションの例；請求書の完了と支払いの完了を行う処理で、請求の完了はできたが、支払いの完了処理でエラーになったときに、請求の処理を未完了に戻す

# 
配送料を追加 →　ワークフローを追加する、ドメインモデルも追加
Vipを追加する　→ フラグ（ステータス）を追加し、それぞれのビジネスロジック内で処理。ドメインモデルは追加しない　Vip用の処理はワークフローを追加する
プロモーションコードを追加する
    → PriceOrder（ワークフロー？）に値段を返却する関数を外から渡たす。値段を計算する関数はプロモーションコードによって切り替える関数を通してPriceOderに渡される
    → さらに複雑な価格計算になったら、ドメインコンテキストとして切り出そう。それを受注、出荷、請求でつかうようにする。
    comsumer driven contactsになっていることが理想的
複数のコンテキストを扱うサービスが必要になったら、それらをサブスクライブする新しいコンテキストを用意する
　