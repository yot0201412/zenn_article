---
title: "Domain Modeling Made Functionalを読んでみる"
emoji: "📗"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ['DomainModelingMadeFunctional']
published: true
---

## この記事について
私が気になった部分やわからなかった部分をメモしていきます。
Domain Modeling Made Functionalの本を要約解説するものではありません。

# 1章 Introducing Domain-Doriven Design
この章は、DDDの基本的な思想について説明されている。
例えば、ドメインエキスパートだけでなく開発チーム全体がドメインについて理解する必要があること、その理解をチームで共有することなど。
高次元のドメインの概念だと、紙だろうがシステムだろうが変わらないはずであるというのは良い言葉。
結構ドメインイベント周りが厚く説明されていて、これからキーになりそう感ある。
ドメインイベントとそれを実行するコマンドのつながりを理解する必要があるっぽい。
1.コマンドが実行される
2.コマンドが成功する
3.ドメインイベントが起きる。
4.ドメインイベントが次に起こすイベントのコマンドを叩く。
この流れで、ひとつながりのプロセスが実行されていく。
大きなドメインは理解できる程度に小さく切り分ける。
"ドメインエキスパートがやっていること"がドメインであるっていうのは、なかなか思い切っているけど良い定義だと思った。
ドメインエキスパートが言うこと・考えていることの一つひとつがドメインそのものと捉えても良さそう。
業務を理解できたら、境界づけられたコンテキストを正しく切ることがまずは大事。
境界を見つけるコツは、
- ドメインエキスパートに聞くこと
- チームや部署の区分けに注目すること
- 大きなコンテキストを作らないこと
- 独立したコンテキストになっているかに着目すること

どんな設計も静的なものではない。
コアなドメインを特定する。基本的には、顧客が最も価値を感じる領域がコアになる。
ユビキタス言語を作りましょう。

トリガー（コマンド）とイベントの違いがちょっと分かりにくかった。
一章はここまで。

# 2章
インタビューは、先入観を持たずドメインの知識を得ることに専念する。
ワークフローの出力は常に次のイベントをトリガーするものである。
→関数型っぽい話しているけど、いまいちわからない。
　注文確認書が出力ではないと言ったこととの違いは何か？アクションではないといけない理由は何？
 トリガーと前章のコマンドの違いは何？
データベースドリブンではなく、モデルドリブンに設計しよう。
　→結構難しいですね。。どうしてもモデルを解釈しながらDBを考えてしまうところがある。みなさんどうですか？
データベースから設計してしまうとモデルをデータベースの都合で捻じ曲げてしまう⇨なるほど。やってしまいそう。
クラスドリブンもだめ。辛い。
技術的なアイデアは後回しにして、まずはドメインに耳を傾けるのだ！
テキストベースの擬似プログラミングでドメインを文書化していく。
→あくまでクラスやDBを作るのではなく、ドメインを少し構造化して捉えることに集中する。
カタログのコピーを持っている件も、ドメインにはならないかもしれないけれど、ニーズ（＝各部署独立して働きたい）を理解する上では必要
→こういう無駄そうなことしている時ってサラッと話を流してしまうことあるけど、これらからニーズを拾っていくことも重要なのね。
ユビキタス言語は結構細かく厳密に作成していく。甘くしてしまうと、設計が形を為さなくなる。
ドメインエキスパートのメンタルモデルにも着目しながら、ドメインを設計する。

# 3章
インタビューやイベントストーミングによって知識を補ってきたが、それをどう設計に繋げるのか。
プロトタイプを作って早めにフィードバックをもらう
C4の話は抽象的すぎてちょっとわからない。
初めから境界を正しく設計するのは難しい（そもそも境界は変化するもの）
モノリスに作ってから、必要に応じてリファクタリングしていくのが良い方法。
コンテキスト間のメッセージングはいろんな方法がある。キュー（Pub/Sub?）は良い方法の一つ。非同期でマイクロサービスでもモノリスでもどちらでも使える。
関数を呼ぶのって依存関係なし（独立している）といえるの？
コンテキスト間で共有可能なDTOを使うことで独立にすることが可能→なるほどね。。DTOをコンテキスト外に定義することにちょっと抵抗感ある。
共通のDTOでメッセージングするのではなく上流DTO⇨JSON/XML⇨下流DTOと言う感じにする。これは良さそう。だけど、一旦JSON挟むの面倒だな。。
[Anything inside the bounded context will be trusted and valid, while anything outside the bounded context will be untrusted and might be invalid.]外部に依存していないことが言いたいのかな？
インプットゲート部分でバリデーションかけるのは良さそう。
アウトプットはセキュリティ意識！
「共有カーネル」・・・お互いが共通のものに依存している。その共通のものの変更には協議がいる
「コンシューマー・サプライヤー」・・・下流が上流に必要なものの提供を求める形式（例：オーダーと通知）
「順応者」・・・下流は上流の変更をそのまま受け入れる形式(例：プロダクトカタログ)
この三つの形のリレーションがある。なるほど。
腐敗防止層パターン・・・レガシーなものとの間に層を設けて独立させる⇦これもインプットゲートになるのか
「The relationship between the order-taking and shipping contexts will be a “Shared Kernel,” meaning that they will jointly own the communications contract.」ここちょっと分かりにくい。。
逆コンウェイの法則！


## 4章
Understanding Functions
関数のイメージ：何かが入り、何らかの形で変換され出てくる。

Types and Functions
関数型プログラミングでは、変数やオブジェクトではなく値と言う単語を使う。
オブジェクト指向では、オブジェクトが値と動作をカプセル化したもので、内部に状態を保つことなる。
これに対して、関数型ではほぼ全てが値であり、関数も「ある型から別の型に値を変更する」型の値であると言える。
図として関数を書いてみる
値、オブジェクト、変数の違い
値：型のメンバーのこと。不変であり、関数も入力(型)→出力(型)に変更する形のメンバーの一つと考えられる
オブジェクト：状態をもつ（状態は変化するもの）
変数：変数は”変化”するもの

Composition of Types
ANDタイプとORタイプの二つがある
ANDタイプ：レコードと呼ぶ。複数の型の複合。F#の複合型のは、クラスとかGoだと構造体にあたる物。
ORタイプ：チョイスと呼ぶ。
101:チョイスは、enumみたい。チョイスにはタグをつける必要がある。
101:これはチョイスに同じ型を複数登録することがしばしばあるため、それらを見分けるときに使う。→結構イメージついてない
関係ないけど、リンゴの型に富士が出てきたのは結構熱い。
104:代数型プログラミングというのはなかなか面白いのかも？「代数的な型システムとは、単純に、すべての複合型が、より小さな型をANDまたはORすることによって構成されるシステムのことである。」
algebraic type systemの話は面白そうなので、少し調べる

Working with F# Types
105:パターンマッチを使って、関数の出力を変化させる方法(match with)の紹介
105:[let​ printQuantity aOrderQty = ...]の書き方をするとなると、新しい型を追加するたびにこんなふうに全部のメソッドを変更しないといけないのだろうか。ちょっと辛いな。新しい型を追加した時の影響範囲の調べ方どうやってやるんだろうか。

Building a Domain Model by Composing Types
1.単純型(値オブジェクト)を作る。
2.次にレコード型（構造体）、チョイス型を作る。
支払い方法の定義だとまず値オブジェクトとして、それぞれの支払い方法を定義した後、それらをチョイス型”支払い方法”として定義している。
支払いのレコードは、金額、通貨単位、支払い方法のレコードとして定義
↑のメソッドは支払い方を定義したもの。現金かカードかなど。
そしてこれらの情報をまとめて、「支払い」という一つの単位ができる。
108:ここまでをまとめると、↑まずは型を作り、その型の遷移をメソッドとして定義していく。というのが関数型の流れっぽい。

Modeling Optional Values, Errors, and Collections
レコードとチョイスはnullを許容していない。
Option<T>をつけるとNullが許容された型を定義できる
オブションラベルもある

エラーの書き方
Result型を定義Result<​'​Success,​'​Failure>
これは、チョイス型で、関数で​Success,​Failureのどちらかを返すように作れる
例：type​ PayInvoice = ​  UnpaidInvoice -> Payment -> Result<PaidInvoice,PaymentError>
PaymentErrorはチョイス型で宣言しておくと、エラーの種別も作成可能

戻り値のない関数
何も返却しないメソッドは書けないが、そういうことをしたい時はunitを使う。
例えば顧客を保存するメソッドの戻り値をunitにするなど。
引数が何もないときも引数にunitを置く。

リスト、コレクション
list, array, ResizeArray, seqが存在する
listはイミュータブルで不変長。
ドメインモデリングではlistと使う
optionと同じように宣言できる
type​ Order = { ​  OrderId : OrderId ​  Lines : OrderLine ​list​ ​// a collection​ ​  }

Organizing Types in Files and Projects
コンパイル順の早いファイルは、遅いファイルを参照できない。
type→domain→common→Order Takeing→Shippingの準にコンパイルする

同ファイル内でも同様で、型の宣言は上から順に宣言されている必要があり、下流の型を使って上流の型をコンパイルできない。
例外的に可能にする方法(rec, and)も用意されているが、リリース前までには正しい依存関係に並べ替える方が良い。



F# の 文法まとめ
- 関数関連
let で関数定義を宣言
returnはなく、最後に表現されたものが戻り値になる。
関数の範囲はインデントで区切る(Pythonみたい)
関数で型を宣言する必要はなく、推論してくれる。
汎用型は'aと表現する

同じかどうか判定する比較演算子は=一つ

レコード型の値の宣言
let​ aPerson = {First=​"Alex"​; Last=​"Adams"​}
レコード型の値の分解
let​ {First=first; Last=last} = aPerson


# 5-7章は省略
7章は自分でもまとめてみたいかも

# 8章
関数型での書き方
Currying, Bakeing in は面白いね。
複数パラメーターの関数を複数の1パラメーター関数の複合体と考えることができる
つまり、3パラメーターの関数を1+1+1, 1+2, 2+1のどれと捉えてもいいってことなのかな？
composionのpipingはOOPだと関数の戻り値をそのまま関数に突っ込んでいる時の感じかな。
ただとても見やすい。
workflowのpipingがapplicationになるところはちょっとよく分からない。in parallelはcomposeなのか？

# 9章
バリデーションとバリデーション済の型を返すメソッドを分けて実装するのは面白い
Implementing the Rest of the Steps
> 必ず起きるイベントも起きないかもしれないイベントもリストで返却する。起きないかもしれないイベントが起きない時も空のリストを返却するようにする
それぞれ別の型を共通のイベント型に変換するのをリフティングと呼ぶ

DIの方法としてモナドもあるけどpartial applicationを使う
参考:https://qiita.com/tadsan/items/cec2851f70838e42be46
関数型プログラミングではいわゆるDIはせず、パラメーターとして明示的に渡すようにする
依存を引数で渡していくのは、依存を解決するトップレベルのメソッドまで続ける必要がある。→これはちょっとめんどくさい
だけど、これによってテストしやすくなる

たくさんの依存があったらどうするか？→1.メソッドを分解する、2.依存をグループ化する
引数が複数必要な関数も、ワークフローを始める前にいくつか引数をセットできるのであれば、先にセットした関数を用意してそれを使うようにする

# 10章
エラーハンドリングについて
エラーも大事な存在である
主にエラーは三種類ある。
ドメインエラー：ビジネスプロセスの中で生じるエラー（→ドメイン知識である）
パニック：アウトオブメモリー等のハンドル不能のエラーやプログラムのミス（ぬるぽとか）
基盤エラー：そのほかドメインには含まれないエラー（認証失敗とかタイムアウトとか）

どれがドメインエラーなのかはドメインエキスパートに聞こう！
ドメインエラーはドメインの一部なので型定義するのがいい。

モデル化したくないエラー（パニック、基盤エラー）はトライキャッチすればOK！
だけど基盤エラーの取り扱いはドメインエキスパートとよく相談して決めるほうがいい

ドメインエラーにはチョイス型を使おう

ライブラリ等を使用している場合は、例外を返さないといけないこともある.
ドメインに関係する例外は例外はドメインエラーとしてキャッチする.
それ以外は、普通に例外を起こして、それで止まるってことでいいのかな？

I/Oへの書き込み等続きがない処理の場合はどうするのか？
関数自体を引数に取るアダプター関数を作成して、Resultを返すようにすることで、次のパイプラインにつなげられるようにする？
⇨細かい話だけどトランザクションの管理とかどうなるんだろう？同じコンテキスト内では流石に整合性を取れるようにしておきたいが、、
あと、全く何も返さない関数って実際どの辺にあるのだろうか？I/Oへの書き込みはエラーが起きうるし、どういうケースを想定した話をしているのだろうか？
logへの出力とかそういうもの？
let!で中身を取りに行けるの面白いし便利。let!を使ってもErrorの型を一致させるためにmapErrorは必要らしい
非同期Resultを使う場合は、すべてのResultを非同期Result型に合わせる必要があるので、そのマッピングが必要になるがlet!を使えばそんなに複雑なものにはならない

# 11章
Parsisitanceの意味は固執するとかより、永続化または一般的な形に変更することを指している
BoundedContext間の密な結合は避けるために、DTOによる縛りは弱いものになってしまうが、変更は慎重に行うようにしましょう→確かに。安易にドメインモデルで送り合うことはやるべきではないし、（マイクロサービス化などを考えると）できないよね。ただし、モノリスの間はそこまで明確にBoundedContextを意識しなくてもいいのでは？
デシリアライズ化のコードで例外を返すか、パニックにするかは、APIの公開度や呼び出し元の信頼度による→公開度が高い場合はPanicより例外をしっかり決めてそれを返してあげるほうが親切で、信頼度が高い（つまりは決まった呼び出し元から呼ばれる場合）はパニックでよいということかな。
toDomainでドメイン作成前にバリデーションかけているのはなぜ？domainのコンストラクタか、型システムを使ったvalidateメソッドでかけるのがいいのでは？
P329: inputにかけるバリデーションってDomainに関係するバリデーションじゃなくて値の有無とかもう少し簡単なもの？でもその場合は、toDomainではなくてInputのバリデーションメソッドとして書いたほうがいいような？
P334:Domainの境界とか名前は変わっていくものだけど、シリアライズ型の名前はコントラクトがあるので簡単に変えるべきではない→公開されているAPIを想定した話でモノリスの場合のBoundedContext間やただのAPIサーバーの場合はDomainに合わせて名前を変えて行ったほうが良さそうだけどどうなんだろう？
P341:型の違うチョイス型もタグを使って表現できる。GraphQLのEnum型（Interface?）にちょっと似ている？
P343:すべての値をタプルKey-Value(obj)のタプルにしてしまうという方法もある。この場合Resultの型にジェネリクスを使うことができる
ここでジェネリクスを使うメリットデメリットってなんだろうか？ケースバイケースだからひとまずあまり気にしなくて良さそうなのかな。

# 12章
永続化
永続化を組み込むとだいたいの場合で、完璧なドメインモデルとミスマッチするようになる
ポイントは３つ
Push persistence to the edges.
Separate commands (updates) from queries (reads).
Bounded contexts must own their own data store.

Push persistence to the edges.
永続化ロジックはそれ単体をテストする必要はない。ただテストが必要ないという意味ではなく、統合テストで一緒にテストする。
どうしても永続化ロジックだけをテストしたいなら、外部から注入する作りにしておく（？）←ここあまりわかってないかも
サービスのテストを統合テストではなく単体テストにしたいならってこと？
I/Oとロジックのサンドイッチがあまりに多重になるようなら小さいワークフローに区切った実装に変更する←たぶん色々やろうとしすぎているってこと
関数型のこの実装方法ではリポジトリーパターンはいらなくなる。
    ←結局同じことしているように思ったけど、リポジトリーパターンとの違いってなんだろう？
        クラスにまとまっていないこと
        リポジトリーを作らず、必要なときに必要な関数をそれぞれ実装する（再利用はあまりかんがえていないのかも？）

Separate commands (updates) from queries (reads).
データの更新もイミュータブルにする
Insert, Update, Deleteはデータストアの状態が変化するが、Read(query)は変化しない
だからCQSではCとQを一緒に扱わない

 データを返す関数は副作用を持つべきではない。
 副作用（状態の更新）を持つ関数は、データを返してはいけない、つまり、単位を返す関数でなければならない。